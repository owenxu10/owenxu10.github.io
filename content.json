{"pages":[{"title":"About Me","text":"Dear visiter(s), Welcome to my personal blog! I am Owen (Junsheng Xu). I work at Google as a Software Engineer I graduated from Carnegie Mellon University in 2019 as a Master in Information Technology. My interest lies in Large Scale Data Processing, Distributed Systems, and Backend Infrastructures. Please feel free to contact me via xjs0229[at]gmail[dot]com. Have fun! Best,Draymonder Owen.","link":"/about/index.html"}],"posts":[{"title":"[SAP]关于ABAP TABLE BUFFER的解释","text":"Index可以被看成是表记录的特殊几个字段的copy。这个copy是排序的，这样可以提高查询表的性能。Index中含有指针用于指向其在表中所在的位置。 使用index时的注意事项： 要利用Index提升性能，索引字段必须位于where子句的最前面。 只用那些可以明显的减少记录数量的字段才适合作为索引。 当修改表中的记录时，索引的顺序就会被改变，所以对于频繁修改的表不适合建索引。 一个表中不同的索引的耦合要尽量松散当要去表中的记录时database optimizer会决定应当使用那个index。用户可以创建自己的index但是必须以Y或Z开始。在创建索引是你可以选择在那些类型的数据库中创建索引。 Table buffer可以大大提高访问表的性能。随着数据的增加对缓存的空间要求越来越多较长时间没有被访问到得数据就会被置换掉。只有当缓存剩余的空间小于阀值或访问性能没有达到要求时缓存中的数据才会被置换掉。可以再command field中敲入/$TAB来清空所在application server上的缓存。/$SYNC可以清空所在application server上的所有缓存。 SAP系统在每个application server上管理和同步缓存。当程序读取表的数据时database interface首先到application server得缓存中去查看是否有符合条件的数据如果有就直接从换从中读取，如果没有就到数据库中去读取，然后把读取到的数据放到缓存中。 按照往换从放数据方式的不同可以分成三种缓冲类型： Full buffer：当表中的一条记录被访问时，所有的记录都会被放到缓存中 Genric buffer：访问到得记录的key的左连接（left join）被缓存。 Single-record buffer：只有被访问到得记录被缓存。Fully buffer：比较小的表，很少被修改适合fully buffer。对于那种场景是表中的记录不存在的查询经常被使用的表也适合做fully buffer。另外对于fully buffer由于buffer中的记录是按照key排序的所以查询条件要充分利用索引，否则的话很有可能性能还没有直接从数据库中访问利用secondary index好。 Single-record buffer适合于select single语句对于select single找不到记录的情况，buffer中也会记录这种情况下找不到，下次使用这个语句时就不会再读取数据库了。 由于buffer是在服务器本地管理的，buffer中的数据必须与数据库同步。同步的动作在一定周期内发生，这个周期是有参数_rdisp/bufreftime设置的。_ Buffer在application server本地保存的有点时减少了网络流量，缺点是在buffer中可能存在脏数据。所以使用buffer时应当注意这几点。","link":"/2015/01/14/ABAP%20TABLE%20BUFFER/"},{"title":"A new blog based on Hexo","text":"要说建立一下这个新的Blog的缘由要说到上周：那天上班开会时，特别无聊（其实一直很无聊） 我便开始刷LeetCode，刷了一会儿想谷歌搜索了一下所有的排序算法。于是在搜索后的前几个答案中偶然进入了一个blog，第一眼就被这个blog的简介的UI吸引。 大家一起欣赏下： http://wuchong.me/blog/2014/02/09/algorithm-sort-summary/拉到最底下发现这是基于HEXO的一个blog。HEXO是啥？我其实也不知道。自从12年跟随狗田建了个WordPress的blog，其他的博客框架都不太熟悉。来自Google的解释：Hexo is a fast, simple and powerful blog framework. You write posts in Markdown (or other languages) and Hexo generates static files with a beautiful theme in seconds. 最主要的是它，是基于Node.js开发的，据说编译速度比别的框架快。 而且，想到自己以前那个老blog已经残花败絮了（留言板什么都用不了了）。不如趁这个机会重建一下我的Blog，来记录记录工作生活的事情。 接下来就是撩起袖子干活了： 1.Deployment乐呵乐呵地选择了Github Page 2.把老文章从WordPress迁移过来得益于HEXO有migration功能，可以将之前的一些文章导入过来。 3.HEXO的theme选择首先想用的是评级最高的NexT，但是相对的用的人也多了些。虽然简约风看起来很干净，可是用了之后觉得黑白的配色还是有些单调。之后偶然的机会看到了这个blog 从而知道这个theme：Icarus，类似于Twitter的bootstrap。 4.网站Icon注意到了标签栏上还有网站标题前的X标志了吗，嘻嘻 5.熟悉HEXO写了这篇文章熟悉熟悉。","link":"/2016/01/12/A%20new%20blog%20based%20on%20Hexo%20/"},{"title":"2017 Happy the year of Rooster","text":"Recently, 鸡年先给自己定一个小目标：做一个网站来学习一些知识，技术栈基本是PostgreSQL, Python Django, Vue.js。至于这个网站是做什么的还没好LOL。 April 27th啥都没做。postgreSQL和Vue.js还是在工作时候学了。只是要靠别人逼才能学呀，囧","link":"/2017/01/29/2017/"},{"title":"Draymond man","text":"小时候，爸爸和我说：人生若有八十年，辛苦二十年就可以享受六十年。如今，我对自己说：人生如逆水行舟，不进则退。 Man, you should always push yourself to persue your dream. 毕业后选择留在了实习的公司SAP，转眼两年了。 //留个坑 感谢你们的支持！是时候放手一搏了! Be a draymond man!","link":"/2016/04/19/Draymond/"},{"title":"JAVA的Random类","text":"Random类 (java.util) Random类中实现的随机算法是伪随机，也就是有规则的随机。在进行随机时，随机算法的起源数字称为种子数(seed)，在种子数的基础上进行一定的变换，从而产生需要的随机数字。 相同种子数的Random对象，相同次数生成的随机数字是完全相同的。也就是说，两个种子数相同的Random对象，第一次生成的随机数字完全相同，第二次生成的随机数字也完全相同。这点在生成多个随机数字时需要特别注意。 下面介绍一下Random类的使用，以及如何生成指定区间的随机数组以及实现程序中要求的几率。 1、Random对象的生成 Random类包含两个构造方法，下面依次进行介绍： a、public Random() 该构造方法使用一个和当前系统时间对应的相对时间有关的数字作为种子数，然后使用这个种子数构造Random对象。 b、public Random(long seed) 该构造方法可以通过制定一个种子数进行创建。 示例代码： Random r = new Random(); Random r1 = new Random(10); 再次强调：种子数只是随机算法的起源数字，和生成的随机数字的区间无关。 2、Random类中的常用方法 Random类中的方法比较简单，每个方法的功能也很容易理解。需要说明的是，Random类中各方法生成的随机数字都是均匀分布的，也就是说区间内部的数字生成的几率是均等的。下面对这些方法做一下基本的介绍： a、public boolean nextBoolean() 该方法的作用是生成一个随机的boolean值，生成true和false的值几率相等，也就是都是50%的几率。 b、public double nextDouble() 该方法的作用是生成一个随机的double值，数值介于[0,1.0)之间。 c、public int nextInt() 该方法的作用是生成一个随机的int值，该值介于int的区间，也就是-231到231-1之间。 如果需要生成指定区间的int值，则需要进行一定的数学变换，具体可以参看下面的使用示例中的代码。 d、public int nextInt(int n) 该方法的作用是生成一个随机的int值，该值介于[0,n)的区间，也就是0到n之间的随机int值，包含0而不包含n。 如果想生成指定区间的int值，也需要进行一定的数学变换，具体可以参看下面的使用示例中的代码。 e、public void setSeed(long seed) 该方法的作用是重新设置Random对象中的种子数。设置完种子数以后的Random对象和相同种子数使用new关键字创建出的Random对象相同。 3、Random类使用示例 使用Random类，一般是生成指定区间的随机数字，下面就一一介绍如何生成对应区间的随机数字。以下生成随机数的代码均使用以下Random对象r进行生成： Random r = new Random(); a、生成[0,1.0)区间的小数 double d1 = r.nextDouble(); 直接使用nextDouble方法获得。 b、生成[0,5.0)区间的小数 double d2 = r.nextDouble() * 5; 因为nextDouble方法生成的数字区间是[0,1.0)，将该区间扩大5倍即是要求的区间。 同理，生成[0,d)区间的随机小数，d为任意正的小数，则只需要将nextDouble方法的返回值乘以d即可。 c、生成[1,2.5)区间的小数 double d3 = r.nextDouble() * 1.5 + 1; 生成[1,2.5)区间的随机小数，则只需要首先生成[0,1.5)区间的随机数字，然后将生成的随机数区间加1即可。 同理，生成任意非从0开始的小数区间[d1,d2)范围的随机数字(其中d1不等于0)，则只需要首先生成[0,d2-d1)区间的随机数字，然后将生成的随机数字区间加上d1即可。 d、生成任意整数 int n1 = r.nextInt(); 直接使用nextInt方法即可。 e、生成[0,10)区间的整数 int n2 = r.nextInt(10); n2 = Math.abs(r.nextInt() % 10); 以上两行代码均可生成[0,10)区间的整数。 第一种实现使用Random类中的nextInt(int n)方法直接实现。 第二种实现中，首先调用nextInt()方法生成一个任意的int数字，该数字和10取余以后生成的数字区间为(-10,10)，然后再对该区间求绝对值，则得到的区间就是[0,10)了。 同理，生成任意[0,n)区间的随机整数，都可以使用如下代码： int n2 = r.nextInt(n); n2 = Math.abs(r.nextInt() % n); f、生成[0,10]区间的整数 int n3 = r.nextInt(11); n3 = Math.abs(r.nextInt() % 11); 相对于整数区间，[0,10]区间和[0,11)区间等价，所以即生成[0,11)区间的整数。 g、生成[-3,15)区间的整数 int n4 = r.nextInt(18) - 3; n4 = Math.abs(r.nextInt() % 18) - 3; 生成非从0开始区间的随机整数，可以参看上面非从0开始的小数区间实现原理的说明。 h、几率实现 按照一定的几率实现程序逻辑也是随机处理可以解决的一个问题。下面以一个简单的示例演示如何使用随机数字实现几率的逻辑。 在前面的方法介绍中，nextInt(int n)方法中生成的数字是均匀的，也就是说该区间内部的每个数字生成的几率是相同的。那么如果生成一个[0,100)区间的随机整数，则每个数字生成的几率应该是相同的，而且由于该区间中总计有100个整数，所以每个数字的几率都是1%。按照这个理论，可以实现程序中的几率问题。 示例：随机生成一个整数，该整数以55%的几率生成1，以40%的几率生成2，以5%的几率生成3。实现的代码如下： int n5 = r.nextInt(100); int m; //结果数字 if(n5 &lt; 55){ //55个数字的区间，55%的几率 m = 1; }else if(n5 &lt; 95){//[55,95)，40个数字的区间，40%的几率 m = 2; }else{ m = 3; } 因为每个数字的几率都是1%，则任意55个数字的区间的几率就是55%，为了代码方便书写，这里使用[0,55)区间的所有整数，后续的原理一样。 当然，这里的代码可以简化，因为几率都是5%的倍数，所以只要以5%为基础来控制几率即可，下面是简化的代码实现： int n6 = r.nextInt(20); int m1; if(n6 &lt; 11){ m1 = 1; }else if(n6 &lt; 19){ m1= 2; }else{ m1 = 3; } 在程序内部，几率的逻辑就可以按照上面的说明进行实现。 4、其它问题 a、相同种子数Random对象问题 前面介绍过，相同种子数的Random对象，相同次数生成的随机数字是完全相同的，下面是测试的代码： Random r1 = new Random(10); Random r2 = new Random(10); for(int i = 0;i &lt; 2;i++){ System.out.println(r1.nextInt()); System.out.println(r2.nextInt()); } 在该代码中，对象r1和r2使用的种子数都是10，则这两个对象相同次数生成的随机数是完全相同的。 如果想避免出现随机数字相同的情况，则需要注意，无论项目中需要生成多少个随机数字，都只使用一个Random对象即可。 b、关于Math类中的random方法 其实在Math类中也有一个random方法，该random方法的工作是生成一个[0,1.0)区间的随机小数。 通过阅读Math类的源代码可以发现，Math类中的random方法就是直接调用Random类中的nextDouble方法实现的。 只是random方法的调用比较简单，所以很多程序员都习惯使用Math类的random方法来生成随机数字。","link":"/2013/03/12/JAVA%E7%9A%84Random%E7%B1%BB/"},{"title":"Leetcode#4","text":"4. Median of Two Sorted Arrays My Submissions QuestionThere are two sorted arrays nums1 and nums2 of size m and n respectively. Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)). Well, the difficulty of this question is hard. It is really tricky if you want the time complexity be O(log(m+n)). Therefore I googled it. And there is an more generic algorithm that to find the Kth element in two sorted array rather than findin the median. To be continued… Honestly I havn’t understand that algorithm yet:)","link":"/2016/01/20/Leetcode-4/"},{"title":"LeetCode#3","text":"3. Longest Substring Without Repeating CharactersGiven a string, find the length of the longest substring without repeating characters. For example, the longest substring without repeating letters for “abcabcbb” is “abc”, which the length is 3. For “bbbbb” the longest substring is “b”, with the length of 1. 一开始理解错了，以为是求最长的重复的Substring长度。。其实后面看是求最长的Substring长度。 主要思路：1、 定义两个pointer，头尾pointer之间一直是当前的最长substring。2、 尾pointer从第二个字符开始遍历整个string。 如果字符没有出现过，则还在substring。如果这个字符曾经出现过，那么需要改变头pointer， 将头pointer指向上一次出现这个字符的位置的后面。3、 还要注意的是 两个pointer只能向前，不能回头。 举个例子： 对于string “abcabca”，当尾pointer遍历到第二个a时，此时需要将头pointer从指向第一个a变成指向第一个b。这样当前头尾pointer之间便是“bca”依旧能求得最长的substring长度。 123456789101112131415public class Solution { public int lengthOfLongestSubstring(String s) { int p1,p2; int max = 0; HashMap&lt;Character,Integer&gt; map = new HashMap&lt;Character,Integer&gt;(); for(p1 = 0, p2= 0; p2&lt;=s.length()-1; p2++){ if(map.containsKey(s.charAt(p2))) p1 = Math.max(p1, map.get(s.charAt(p2))+1); map.put(s.charAt(p2), p2); max = Math.max(max,p2-p1+1); } return max; }} 运行完后发现这个居然不是花的时间最少的！ 在机智的网友中找到了这么一个最佳的答案，其实思路是一样的。借鉴Kadane’s Algorithm，将空间复杂度从之前的O(n)变成了O(1)。 “当一个算法的空间复杂度为一个常量，即不随被处理数据量n的大小而改变时，可表示为O(1)；当一个算法的空间复杂度与以2为底的n的对数成正比时，可表示为0(10g2n)；当一个算法的空I司复杂度与n成线性比例关系时，可表示为0(n).” Check the code: 123456789101112131415161718192021222324252627282930313233public class Solution { public int lengthOfLongestSubstring(String s) { int lastIndices[] = new int[256]; for(int i = 0; i&lt;256; i++){ lastIndices[i] = -1; } int maxLen = 0; int curLen = 0; int start = 0; int bestStart = 0; for(int i = 0; i&lt;s.length(); i++){ char cur = s.charAt(i); if(lastIndices[cur] &lt; start){ lastIndices[cur] = i; curLen++; } else{ int lastIndex = lastIndices[cur]; start = lastIndex+1; curLen = i-start+1; lastIndices[cur] = i; } if(curLen &gt; maxLen){ maxLen = curLen; bestStart = start; } } return maxLen; }} P.S.Kadane’s Algorithm is an O(n) algorithm for finding the maximum contiguous subsequence in a one-dimensional sequence.","link":"/2016/01/15/LeetCode-3/"},{"title":"Leetcode#1","text":"1. Two SumGiven an array of integers, find two numbers such that they add up to a specific target number. The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2. Please note that your returned answers (both index1 and index2) are not zero-based. You may assume that each input would have exactly one solution. Input: numbers={2, 7, 11, 15}, target=9 Output: index1=1, index2=2 My attmpt: Two Sum123456789101112131415161718public class Solution { public int[] twoSum(int[] nums, int target) { int[] result = new int[2]; int p1 = 0; int p2; while(p1&lt;=nums.length-2){ for(p2 = p1+1;p2&lt;=nums.length-1;p2++){ if(nums[p1]+nums[p2]==target){ result[0]=p1+1; result[1]=p2+1; break; } } p1++; } return result; }} However, the time complexity of this answer is O(n^2).So the code might run slow. 求解算法的时间复杂度的具体步骤是: ⑴ 找出算法中的基本语句； 算法中执行次数最多的那条语句就是基本语句，通常是最内层循环的循环体。 ⑵ 计算基本语句的执行次数的数量级； 只需计算基本语句执行次数的数量级，这就意味着只要保证基本语句执行次数的函数中的最高次幂正确即可，可以忽略所有低次幂和最高次幂的系数。这样能够简化算法分析，并且使注意力集中在最重要的一点上：增长率。 ⑶ 用大Ο记号表示算法的时间性能。 将基本语句执行次数的数量级放入大Ο记号中。 如果算法中包含嵌套的循环，则基本语句通常是最内层的循环体，如果算法中包含并列的循环，则将并列循环的时间复杂度相加。例如： 12345for (i=1; i&lt;=n; i++) x++; for (i=1; i&lt;=n; i++) for (j=1; j&lt;=n; j++) x++; 第一个for循环的时间复杂度为Ο(n)，第二个for循环的时间复杂度为Ο(n2)，则整个算法的时间复杂度为Ο(n+n^2)=Ο(n^2)。 摘自: http://blog.csdn.net/zolalad/article/details/11848739 Better solution This solution uses HashMap and the time complexity is O(n). Check the code. Two Sum Better solution12345678910111213public int[] twoSum(int[] numbers, int target) { int[] result = new int[2]; Map&lt;Integer, Integer&gt; map = new HashMap&lt;Integer, Integer&gt;(); for (int i = 0; i &lt; numbers.length; i++) { if (map.containsKey(target - numbers[i])) { result[1] = i + 1; result[0] = map.get(target - numbers[i]); return result; } map.put(numbers[i], i + 1); } return result;}hexo","link":"/2016/01/13/Leetcode-1/"},{"title":"Leetcode-48","text":"48. Rotate Image Add to List You are given an n x n 2D matrix representing an image. Rotate the image by 90 degrees (clockwise). Follow up:Could you do this in-place? 说来很简单就是将一个二维数组按照顺时针旋转90度的操作。这个题感觉不难，但是在做的时候感觉学到不少，特地写下来。 1234eg: 1 2 3 7 4 1 4 5 6 =&gt; 8 5 2 7 8 9 9 6 3 解法:解法有很多，可以先倒序再翻转。 1231 2 3 7 8 9 7 4 14 5 6 =&gt; 4 5 6 =&gt; 8 5 27 8 9 1 2 3 9 6 3 这里还看到一个和我思路相近，但是比我写的好的一个解法。 1234567891011def rotate(self, matrix): &quot;&quot;&quot; :type matrix: List[List[int]] :rtype: void Do not return anything, modify matrix in-place instead. &quot;&quot;&quot; n = len(matrix) for i in range(n/2): for j in range(n-n/2): matrix[i][j],matrix[j][~i],matrix[~i][~j],matrix[~j][i] \\ = matrix[~j][i],matrix[i][j],matrix[j][~i],matrix[~i][~j] 这里的i，j很搞，还没研究透彻。具体思路就是把matrix分四份把每部分向右旋转。另外这个让我学到了~x的用法： ~ xReturns the complement of x - the number you get by switching each 1 for a 0 and each 0 for a 1. This is the same as -x - 1. 另外有一种不是很in-place但是很pythonic的解法： 123456def rotate(self, matrix): &quot;&quot;&quot; :type matrix: List[List[int]] :rtype: void Do not return anything, modify matrix in-place instead. &quot;&quot;&quot; matrix[:] = zip(*matrix[::-1]) list[::-1]原来和list.reverse()的效果相同，又学到了！","link":"/2017/05/06/Leetcode-48/"},{"title":"Leetcode#5","text":"5. Longest Palindromic SubstringGiven a string S, find the longest palindromic substring in S. You may assume that the maximum length of S is 1000, and there exists one unique longest palindromic substring. #What is the ‘Longest Palindromic Substring’#最长回文子串一个字符串中连续的一段就是这个字符串的子串，而回文串指的是12421这种从前往后读和从后往前读一模一样的字符串，所以最长回文子串的意思就是这个字符串中最长的身为回文串的子串。In computer science, the longest palindromic substring or longest symmetric factor problem is the problem of finding a maximum-length contiguous substring of a given string that is also a palindrome. For example, the longest palindromic substring of “bananas” is “anana”. 第一种方法就是遍历整个数组，将每个字符作为回文子串的中心搜索最长子串。这种方法最无脑，同时也是时间复杂度高的。My noob attmpt: Longest Palindromic Substring12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public class Solution { public String longestPalindrome(String s) { String longs = null,templongs = null; int llength = 0, templength = 0; int length = s.length(); int left, right; if (length == 1){ llength = 1; longs = s; } for(int i = 1; i &lt; length; i++){ //odd left = i-1; right = i+1; for(;(left &gt;= 0)&amp;&amp;(right &lt; length); --left,++right){ if(s.charAt(left)!= s.charAt(right)){ break; } } templength = right - left -1; templongs = s.substring(left+1, right); if(templength &gt; llength){ llength = templength; longs = templongs; } //even left = i-1; right = i; for(;(left &gt;= 0)&amp;&amp;(right &lt; length); --left,++right){ if(s.charAt(left)!= s.charAt(right)){ break; } } templength = right - left -1; templongs = s.substring(left+1, right); if(templength &gt; llength){ llength = templength; longs = templongs; } } return longs; }} 第二种方法的时间复杂度就只有O(n)。那就是Manacher’s Algorithm.","link":"/2016/03/17/Leetcode-5/"},{"title":"情人节出发的旅行","text":"这是篇游记。2.14 和宝宝去了苏梅岛、龟岛旅游。 占个坑，以后填:P","link":"/2016/04/19/Thailand/"},{"title":"[SAP]The difference of three HANA views","text":"Recently I was working for a project based on SAP HANA. However, There is one question makes me confused. That is What is the difference between Attritube view, Analytical view and Calculative view. I remember teacher told us before but I do not remember it… Here is the explanation from the SAP forum which may help you to understand these three views better. **Attribute Views ** As we are groupingCustomer informations together,its called Customer Attribute View. Product related informations together,its called Product Attribute View Attribute Views are basically the Master data(descriptive data).Analytical ViewWhen you combine this Attribute Views(Both Customer and Product) along with “Net Sales &amp; Quantity Sold”,it will be called as Analytical View Combining master data with transactional data =&gt; Analytical ViewCalculative ViewLets say you created one Analytical View which has the data for Year 2010 and you have another Analytical View which has the data for Year 2011.You want to combine these two data together in single view,then that is called as Calculation View(Kind of Multiprovider)","link":"/2013/09/23/The%20difference%20of%20three%20HANA%20views%20/"},{"title":"This is my house!","text":"本朱！哈喽！大家好！~这里就是我XUXU的个人主页啦。最近刚建成的，现在一切都还很生疏呢，连换个域名我都不会呢。 说到为什么要建这个独立博客呢，嗯。首先呢，一直以来就想有个地方写写身边发生的事情，对周边发生的事情评论下，以前一直在人人上、微博上干这事。最近我这个微博控对于微博的兴趣也一天天地减少了，都懒得上微博发微博了。再加上明年马上就要去美利坚了，到时候会有一堆游览照片和游览时候的心得体会，那到时候就能实时地在这里和大家分享啦。 其次呢，一般的软件大牛们呢都有个自己的技术博客。而我这个小小牛呢也就在这里建个小地方来记录记录学习心得，学习笔记什么的，让自己在这广袤的网络中有自己的一席之地。最后呢，建立这个博客是来自神一般的室友阿不思辛的个人博客影响，所以我也决定跟随他的脚步，弄个个人博客玩玩。 最近到期末了，闲话什么的就先说到这里。等我十号考完了，就会再把它美化美化，塑造塑造。以后这里就是我在网络上的一个独立的空间了，大家如果想知道我的一些动态啦，及时联系我的话，就赶紧收藏这个网站啦啦啦 :)","link":"/2012/12/28/This%20is%20my%20house!'/"},{"title":"The schedule of spring 2013","text":"Code Desc Time ECON201 04 Economic Principles 9:05-10:05 CE491 01 App Develpmnt for Mobile Devices 11:20-12:20 CE491 02L App Develpmnt for Mobile Devices Lab 10:15-12:20 COMM435 Written &amp; Oral Communication for Overseas Students 1:20-3:25 CS341 01 Web Software Tools 3:35-5:10 CS341 02L Web Software Tools Lab 3:35-5:40","link":"/2013/01/29/The%20schedule%20of%20spring%202013/"},{"title":"The plan of the winter vocation","text":"寒假里要做的事： 1. XML项目。SVRPlatform的增加Web-Service功能，Deadline:2/22 2. About SAP。看两本书《Html5 24-Hour Trainer》和《The Definitive Guide to HTML5》，写读后感。Deadline:2/26 3. 看完圣诞节买的两本书~ 4. 办签证，出国交换的一些琐事。 5. 玩耍~哈哈哈哈","link":"/2013/01/12/The%20plan%20of%20the%20winter%20vocation/"},{"title":"[IOS学习笔记]关于@synthesize obj&#x3D;_obj的意义","text":"我们在进行iOS开发时，经常会在类的声明部分看见类似于@synthesize window=window; 的语句，那么，这个window是什么， window又是什么，两个东西分别怎么用，这是一个比较基本的问题，也关乎我们理解Objective-C中对类、类的属性、类的存取器、类的局部变量的统一理解。 在32位系统中，如果类的 @interface 部分没有进行 ivar 声明，但有 @property 声明，在类的 @implementation 部分有响应的 @synthesize，则会得到类似下面的编译错误：Synthesized property ‘xX’ must either be named the same as a compatible ivar or must explicitly name an ivar 在 64-bit时，运行时系统会自动给类添加 ivar，添加的 ivar 以一个下划线”_”做前缀。上面声明部分的 @synthesize window=_window; 意思是说，window 属性为 _window 实例变量合成访问器方法。也就是说，window属性生成存取方法是setWindow，这个setWindow方法就是_window变量的存取方法，它操作的就是_window这个变量。通过这个看似是赋值的这样一个操作，我们可以在@synthesize 中定义与变量名不相同的getter和setter的命名，籍此来保护变量不会被不恰当的访问。 下面是一个常见的例子 写法一： C代码 [c] @interface MyClass:NSObject{ MyObjecct *_myObject; } @property(nonamtic, retain) MyObjecct *myObject; @end @implementatin MyClass @synthesize myObject=_myObject; [/c] 写法二： C代码[c] @interface MyClass:NSObject{ } @property(nonamtic, retain) MyObjecct *myObject; @end @implementatin MyClass @synthesize myObject=_myObject; [/c]这个类中声明了一个变量_myObject，又声明了一个属性叫myObject,然后用@synthesize生成了属性myObject的存取方法，这个存取方法的名字应该是：setmyObject和getmyObject。@synthesize myObject=_myObject的含义就是属性myObject的存取方法是做用于_myObject这个变量的。这种用法在Apple的Sample Code中很常见。 弄明白了这个语句的意思之后，我们也就清楚了myObject和_myObject的区别，那么，在使用的时候，有什么需要注意的地方，大家应该也都清楚了。是的，myObject是属性，而_ myObject才是变量，我们最终操作的变量都是myObject。 那么，同样是存取操作，语句 C代码[c] self.nameVarPtr = [[ObjectName alloc] init] [/c]C代码[c] nameVarPtr = [[ObjectName alloc] init] [/c]两种赋值方式的区别何在呢？ self.nameVarPtr=xxx 这种赋值方式等价于调用 [self setnameVarPtr:xxx], 而setnameVarPtr:xxx的方法的实现又是依赖于@property的属性的，比如retain，assign等属性。 nameVarPtr = xxx 的赋值方式，仅仅是对一个指针进行赋值。nameVarPtr仅仅是一个指针变量，记录了xxx的地址。在这个过程中不会调用setter方法，不会调用setter方法，就和@property没有关系，从而，也和retain，assign等属性没有关系。这种赋值方式就是一个简单的指针赋值。 综上，对成员变量进行赋值，为防内存泄露需要注意的点： 1.self调用setter方法的方式[c] ObjectName* tmp= [[ObjectName alloc] init]； self.nameVarPtr =tmp; //retainCount=2 [tmp release]; //retainCount=1 [/c]2.指针赋值方式，不会调用setter方法[c] nameVarPtr= [[ObjectName alloc] init]； // retainCount=1 [/c]所以，笔者建议大家在对某个变量进行赋值操作的时候，尽量要写self.myObj = xxx; 这才是最可靠的方法。","link":"/2013/04/16/%E5%85%B3%E4%BA%8E@synthesize%20obj=_obj%E7%9A%84%E6%84%8F%E4%B9%89/"},{"title":"[IOS学习笔记]关于IOS strong 和weak的理解","text":"转：http://stackoverflow.com/questions/9262535/explanation-of-strong-and-weak-storage-in-ios5 The difference is that an object will be deallocated as soon as there are no strong pointers to it. Even if weak pointers point to it, once the last strong pointer is gone, the object will be deallocated, and all remaining weak pointers will be zeroed out. Perhaps an example is in order. Imagine our object is a dog, and that the dog wants to run away (be deallocated). Strong pointers are like a leash on the dog. As long as you have the leash attached to the dog, the dog will not run away. If five people attach their leash to one dog, (five strong pointers to one object), then the dog will not run away until all five leashes are detached. Weak pointers, on the other hand, are like little kids pointing at the dog and saying “Look! A dog!” As long as the dog is still on the leash, the little kids can still see the dog, and they’ll still point to it. As soon as all the leashes are detached, though, the dog runs away no matter how many little kids are pointing to it. As soon as the last strong pointer (leash) no longer points to an object, the object will be deallocated, and all weak pointers will be zeroed out. （weak和strong）不同的是 当一个对象不再有strong类型的指针指向它的时候 它会被释放 ，即使还有weak型指针指向它。一旦最后一个strong型指针离去 ，这个对象将被释放，所有剩余的weak型指针都将被清除。 可能有个例子形容是妥当的。 想象我们的对象是一条狗，狗想要跑掉（被释放）。 strong型指针就像是栓住的狗。只要你用牵绳挂住狗，狗就不会跑掉。如果有5个人牵着一条狗（5个strong型指针指向1个对象），除非5个牵绳都脱落 ，否着狗是不会跑掉的。 weak型指针就像是一个小孩指着狗喊到：“看！一只狗在那” 只要狗一直被栓着，小孩就能看到狗，（weak指针）会一直指向它。只要狗的牵绳脱落，狗就会跑掉，不管有多少小孩在看着它。 只要最后一个strong型指针不再指向对象，那么对象就会被释放，同时所有的weak型指针都将会被清除。 &amp;nbsp;","link":"/2013/04/14/%E5%85%B3%E4%BA%8EIOS%20strong%20%E5%92%8Cweak%E7%9A%84%E7%90%86%E8%A7%A3/"},{"title":"写于13年1月1日","text":"现在是2013年1月1日凌晨1点1分，新的一年又来了。我正在听着洗剪吹的新歌，思忖着到底在这篇文章写些什么东西。 那就先来点总结: 回首2012年，发生的一些事情让我以为那就是世界末日。可是那些打败不了你的困苦最后改变的只是让人更强大。在大三开始后我便申请到了去美国交换的名额。自己也在2012年找了实习单位，认识了许多新朋友。也许某天回头看那些事，会真的做到宋老师说的那种“回首向来萧瑟处，也无风雨也无晴”的样子。 接下来展望下2013年。2013年呢，先好好复习，在期末要考个好成绩，然后再在寒假里学习点生存技能，再然后就要去美国学习生活三个月，要好好珍惜这三个月，每天都要有意义的过~最后回来后呢就要去SAP实习了，要好好表现争取留下来啊。保研什么的就再说了。2013满扑扑呐！2013闪亮亮呐！2013年中还有一点我要做到的就是早睡早起，好好养身！:) :) 那就让过去过去，让未来到来吧！最后祝大家新年新气象Happy new year","link":"/2013/01/01/%E5%86%99%E4%BA%8E13%E5%B9%B41%E6%9C%881%E6%97%A5/"},{"title":"关于出现空白页500error的解决方法","text":"之前在将wordpress从原默认域名 改到现在这个域名情况发生了500error。在谷歌了这个问题无果后向客服寻求了帮助。客服让我用PHP探针试一下，就知道是什么错误了。 探针方法如下： 1)创建一个空白记事本 2)在里面加一句“php_value display_errors on”后，保存为“.htaccess”这个是文件名，要选择所有文件保存。 3)把它丢到你wordpress根目录下。他就能显示出你的问题了。 P.S. 别忘看下权限，必须设置为644以上的。","link":"/2013/01/01/%E5%85%B3%E4%BA%8E%E5%87%BA%E7%8E%B0%E7%A9%BA%E7%99%BD%E9%A1%B5500error%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/"},{"title":"我的Hackintosh终于有声音了","text":"昨天晚上和庆伟去上了节课，课上闲着没事去了远景论坛搜了搜，看看有没有大神发帖帮我解决我的声卡问题。然后就看到了这个帖子http://bbs.pcbeta.com/forum.php?mod=viewthread&amp;tid=997093然后我就去按照10楼的大神弄了个万能声卡补丁。一开始开机五国，之后重启就有声音了。现在我的MACOS就基本上已经成型了，除去偶尔玩玩游戏之外，其他的事情基本上能在我的黑苹果完成啦！ p.s. 试试微博文章同步的插件的效果～～","link":"/2013/03/07/%E6%88%91%E7%9A%84Hackintosh%E7%BB%88%E4%BA%8E%E6%9C%89%E5%A3%B0%E9%9F%B3%E4%BA%86/"},{"title":"沙发土豆的由来","text":"我有一种预感，这寒假我可能就要成为沙发土豆了。 只是因为在昨天我为了追求大屏幕的效果，拿hdmi线把笔记本连到了电视上，然后又拿了床桌放在沙发上，配上无线键盘鼠标。哇塞。现在一个遥控器，一个键盘，一个鼠标就能彻底的享受电视机当显示屏，超大屏幕的非凡感受啊。 太爽了！！ 于是，一个沙发土豆就诞生了- -","link":"/2013/01/19/%E6%B2%99%E5%8F%91%E5%9C%9F%E8%B1%86%E7%9A%84%E7%94%B1%E6%9D%A5/"},{"title":"申请总结","text":"昨天刚把匹兹堡的租房的申请发了，忽然意识到离去CMU只有4个月不到了。趁着有时间和念头来做个这次的MS申请总结。 这次总共申了11个学校，结果为2/11:AD:CMU INI, UMN CSRej: UCLA, UIUC, UTAustin, Gatech, UMD, DUKE, Purdue,PSU,Pending: USC(花了老子最多钱的垫底校至今杳无音讯) 总的来说虽然申请结果比较惨烈，但是我还是很满意的。不能从ad和rej的比例来判断结果，其实我心里目标很明确，我选的学校都是TOP30，虽然有失学的危险，但只要一个ad就够了，能来两个已经很好了。 比起别人在三月四月等着一个个学校的开奖不一样，我的申请季其实在三月五号就结束了。CMU第一个发来了邮件给了我AD，然后又补了1w3的小奖。中了CMU这个dream school，其他的学校真的都是浮云了。但是本以为会有很多其他学校ad会兵至踏来，结果却等来了一个七连拒，哎，纯CS果然很难申，特别还是我这种菜鸡。 回想起申请的过程，从去年七月辞职开始准备，花了2个月把G上了320，九月第一次的T感觉不错结果只考了93，这应该是申请中真的是最紧张的时候了，感觉要没学上了，一个个学校去查最低托福分数线，还好一周之后的T神奇地考了104。再加上看的过去的GPA和SAP工作经验，让我好好可以搏一波这些Top30的学校了。 最后感谢一路在申请路上帮助过我的人吧。让我啃老几个月的爸妈，一直支持我陪我的宝贝，帮我操刀文书的龚老师，帮我写推荐信的凯特琳的老师，同济的张老师，史老师，sap的刚哥，特别要感谢我的老板，帮我交了11份推荐信。申请之路看似顺风顺水，实则崎岖不平，真的只有非常努力才能看起来毫不费力。其实人生中其他的事情也是这样。感谢CMU看走了眼给了我这个机会，希望日后证明你的选择。Be humble! P.S. 写这篇的还有个目的是最近有些颓废，总是不想刷题，看15513。希望写下这篇来激励一下自己，回到那个努力学习GRE的自己，因为人生就是要不断努力呀！","link":"/2017/04/27/%E7%94%B3%E8%AF%B7%E6%80%BB%E7%BB%93/"},{"title":"谷歌面试总结","text":"我毕业啦！ 同时从今年2月末开始, 我就要开始在Mountain View谷歌总部开始软件工程师的工作啦。回顾求职的路程，感觉有惊无险，顺利拿到了狗家的offer，达到了出国前定下的小目标。现在理一理时间线，记录一下一路走来的过程。 2018年夏天，当谷歌秋招开始之后，立马找了学姐内推了谷歌。并且在7.23，那天还在AMD实习，跑到车内接完狗家HR打来的电话，讲述了之后的process并只给我免去了OA（CMU的都免电面好吗。因为在实习后要和宝宝出去玩，所以电面往后推了一个多月定在了9月4号。电面题目不难，是Permutation Sequence。我没用最优的方法做，而是用了Next Permutation做了。在这里要感谢面试官抬我一手让我过了。在9月14日收到了电面通过的电话。 并且安排了新的HR，以及约了Onsite。然后就是10月10日的Onsit interview。一天面了五轮算法，面完后腰酸背痛。 五轮题目分别是 实现addRange(int start, int end); isInRange(int num); isInRange说一下用O(N), O(logN), O(1)实现; 写了O(logN) follow up: needle in a haystack search 类似KMP字符串匹配 机器人走路 robot(List command, int[][] obstacles); 汇率转换 follow up: 用union-find 解 binary tree 里多了个extra edge 让tree invalid 找到并删除该边; follow up: extra edge 是因为有个node 有三个children的情况，找到并删除该边 一堆坐标点 找最小的长方形的面积 follow up：长方形可以不和x, y 轴 平行 五天后，HR告知过了onsite，于是开始为期一周的team match。最终，从Local Search Query, Geo Infrastructure和Google Analytics中选择了Google Analytics，干的活简单来说就是洗数据，详细点就是用MapReduce等技术把Google Analytics收集到的数据进行处理，可以让其他team更方便的进行分析。一切搞定之后在10月30日送了hc，并在11月5日被告知过了hc，11月6日SVP签字了，开始谈compensation。拉拉扯扯之后在11月19日签了offer。 有幸能加入谷歌，和一堆大牛一起共事，要好好加油！在工作中更耐心努力，同时要重拾因为CMU繁重的课业而忽略的健身。Keep building my life！","link":"/2019/01/19/%E8%B0%B7%E6%AD%8C%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"},{"title":"美利坚的惬意生活","text":"从踏上美国国土到现在已经一个多星期了。这一周其实是开学前一周，应该是适应周。之前几天老师带着我们参观学校，教我们如何用学校的系统，顺便带我们去弗林特周围的沃尔玛，outlet(奥特莱斯)去转转。 之后我们便搬进了学生寝室了，美国的学生寝室和中国不一样。一般寝室是五人一间，一个大厅，五个起居室，两个卫生间和一个厨房。寝室的装置很全，洗衣机干洗机，电视机，洗碗机，烤箱，冰箱。美国人也真是懒，洗个碗都能有洗碗机这种东西存在。不过其他的锅碗瓢盆都要买，食物也是。当一切东西都添置完毕后，整个寝室有种家的感觉。我室友是两个德国人，一个墨西哥人，还有个人签证有问题暂时还没来。德国人三天两头就会搬啤酒回寝室，冰箱里有两箱啤酒是常有的事情。墨西哥人很好，还教了我怎么使用这里的洗衣机和干洗机。 最后便是这个周末的复活节了。 “复活节（主复活日）是现今基督教徒的重要节日之一，定在每年春分月圆之后第一个星期日。基督徒认为，复活节象征重生与希望，乃纪念耶稣基督于公元33年被钉死后第三天复活的事迹。” –维基百科 关于复活节我知道的也不是很多，只是跟着一些美国人听着，看着，感受着这种异国他乡的宗教文化。复活节周末的周五叫做Good Friday也就是耶稣受难日，在周五那天，他们在我们去了底特律的一个剧场，教堂当晚包下了这个剧场，有乐队在唱着”Jesus is dead and Jesus is risen” 之类的宗教颂歌。之中不断穿插着一个近乎狂热的演讲者诉说着Jesus如何为我们牺牲，如何为我们付出。总的来说就好像一个小型演唱会。只是在唱歌的时候几乎所有人都会站起来一起唱，所以你也只能一起站着感受着，也是个累人的事情。 而复活节一般会放在周日。那天我们早上和美国学生一起去了教堂，听着颂歌，还有一些仪式，比如圣礼餐。就是每人发块小饼干和一杯小葡萄汁代表着Jesus的身体和血，把这些吃了喝了后就代表着记住了他的牺牲，表明主的死，直等到他复活归来。结束后我们就一起去了一个热情的美国人家吃复活节大餐。美国人住的房子以及周围的秋千，椅子，小木筏都是自己造的。门前还有个湖水也是属于美国人家的。老美很热情做了很多复活节食物，我是第一次吃到如手掌一样大的火腿。吃完后那家子的小辈们带我们去房间周围散步，当时感觉完全是在一个大公园里散步。之后一堆人又开始荡秋千，划木筏，玩**梨球。最后一堆人还**围在一起丢飞盘(frisbee)，老美还教了我怎么丢橄榄球:) 我怕直接传照片，空间会不够。所以照片都传上flickr了。http://www.flickr.com/photos/94564081@N03/","link":"/2013/04/03/%E7%BE%8E%E5%88%A9%E5%9D%9A%E7%9A%84%E6%83%AC%E6%84%8F%E7%94%9F%E6%B4%BB/"}],"tags":[{"name":"SAP","slug":"SAP","link":"/tags/SAP/"},{"name":"Intro","slug":"Intro","link":"/tags/Intro/"},{"name":"Dream","slug":"Dream","link":"/tags/Dream/"},{"name":"JAVA","slug":"JAVA","link":"/tags/JAVA/"},{"name":"LeetCode","slug":"LeetCode","link":"/tags/LeetCode/"},{"name":"Algorithm","slug":"Algorithm","link":"/tags/Algorithm/"},{"name":"Love","slug":"Love","link":"/tags/Love/"},{"name":"Kettering","slug":"Kettering","link":"/tags/Kettering/"},{"name":"Vacation","slug":"Vacation","link":"/tags/Vacation/"},{"name":"IOS","slug":"IOS","link":"/tags/IOS/"},{"name":"Wordpress","slug":"Wordpress","link":"/tags/Wordpress/"},{"name":"Hackintosh","slug":"Hackintosh","link":"/tags/Hackintosh/"},{"name":"CMU","slug":"CMU","link":"/tags/CMU/"},{"name":"DREAM","slug":"DREAM","link":"/tags/DREAM/"},{"name":"GOOGLE","slug":"GOOGLE","link":"/tags/GOOGLE/"}],"categories":[{"name":"About Work","slug":"About-Work","link":"/categories/About-Work/"},{"name":"Misc","slug":"Misc","link":"/categories/Misc/"},{"name":"About Life","slug":"About-Life","link":"/categories/About-Life/"},{"name":"About Study","slug":"About-Study","link":"/categories/About-Study/"},{"name":"About U.S.A","slug":"About-U-S-A","link":"/categories/About-U-S-A/"}]}